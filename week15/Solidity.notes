# What is Solidity ? 
 
 Solidity is a high-level, statically-typed programming language used to write smart contracts for Etherium
 and other blockchain platforms that are compatible with the Etherium Virtual machine (EVM). These smart contracts are self-executing contracts with the terms 
 of the agreement directly written into code.



#ABIs 
  In Etherium, an ABI(application Binary interface) is a standardized way for interacting with smart contracts. it defines how data should be encoded and 
  decoded when being sent to and from a contract on the Etherium blockchain.



Solidity Version
  - The version statement at the top of a 
  Solidity contract specifies the version of the solididy 
  compiler that should be used to compile the contract.


  ex - 

  pragma solidity ^0.8.0;

  contract Sum {
    function sum(uint a, uint b) public pur
        return (a+b, a);
  }



# Variables -> 
      In Solidity, variables are used to store data within a contract. They can 
      hold different types of values and are fundamental to writing smart contracts.

      for example - for a Decentralized Uber app, 
                    You would store things like 

                    1.Rides
                    2.Users
                    3.Locations
                    4.Payments


     Types of Variables 

     1.Unsigend Numbers 
         a.uint8 = small Numbers  //here u is for unsigned means the number is not negative 
         b.uint16 = 16 bit Numbers
         c.uint255 = 256 bit number(uint)    


         ex - 

          contract Sum {
            unit8 gender;
            unit calls;
            unit bigNumber = 100000;
          }           


      2.Signed Numbers 

             a.int
             b.int32

     3.Booleans
        1.true
        2.false

     4.Addresses 

         - address store an etherium address              


     5.Strings    



# Constructor 

      A Constructor in Solidity is a special function that is executed only once during the 
      deployment of the contract. Its primarly purpose is to initialize the contracts state variables and set up any required 
      logic when the contract is deployed to the Etherium blockchain.


      ex - 

      pragma solidity ^0.8.0;

      contract Calculator {
        uint256 currentValue;

        constructor(uint256 _initialValue) {
              currentValue = _initialValue;
        }
      }

#Two types of functions:

  - State-changing functions: Functions that modify state variables, interact with other 
    contracts, or send/recieve Ether require a transaction and are considerd "non-view" functions.
   
  - view  functions : 

# View 

   In Solidity, the view keyword indicates that the function does not modify the state of the blockchain.
   It is a type of function modifier that tells the Etherium virtual machine (EVM) that the function is read-only ad will
   not alter any operations that would require a transaction.


# Mapping 

   In Solidity, a mapping is a data structure that allows you to store and look up key-value pairs.
   It's similar to a hash table or dictionary in other programming languages.


   ex- 

       1.create mapping -
          mapping(address => string) public names;

       2.Insert into a mapping -
          names[msg.sender] = _name;

       3.Get from a mapping 
           names[_address];   
             


 #Assignment ->

     Q. Create a user contract where users can come and sign up   


     -------> 

     pragma solidity ^0.8.0;

     contract NameRegistry {

      mapping(address => string) public names;

      function setName(string memory _name) public {
        names[msg.sender] = _name;
      }

      function getName(address _addres) public view returns (string memory) {
        return names[_address];
      }
     }         


          


# Arrays 

  There are two types of arrays in Solidity 

        1.Fixed-size arrays:  Arrays where the size is defined when the array is created, and it cannot be changed afterward.

        example - 
         uint[3] public numbers;

        2.Dynamic Arrays : Arrays where the size can change dynamically during execution(i.e, you can add or remove elements).

        example -
            uint[] public numbers;



# Struct 

    In solidity, a struct is a custom data type that allows you to group multiple 
    variables (of different types) together into a single unit.

    example - 

    struct Person {
      string name;
      uint age;
      address add;
    }
    Person public person;
    
     function setPerson(string memory _name, uint _age, address _add) public {
      person.name = _name;
      person.age = _age;
      person.add = _add;
     }



# Assingment 2 - create a personsContract 

--> 

   contract PersonContract {

    struct Person {
        string name;
        uint age; 
        address addr;
    }

    mapping(address => Person) public persons;

    function setPerson(string memory _name, uint _age) public {
      persons[msg.seder] = Person({
        name; _name,
        age: _age,
        addr: msg.sender
      });
    }

    function getPerson() public view returns(string memory, uint, address){
       Person memory person = persons[msg.sender];
       return (person.name, person.age, person.addr);
    }
   }




# Memory VS Stack VS Storage 


      In Solidity, Memory, Stack, and Storage are three distinct locations where data can be stored.
      Each has its own characteristics, use cases, and costs.


      Storage - 

           Stoage refers to the presistent data that is saved on the blockchain. it is used for state 
           variables that you declare at the contract level.
           Data stored in storage is written to the blockchain and remains there permanently, 
           accross function calls and transactions, untill it is explicitly modified.  

           Writing to storage is costly in terms of gas 
           because it requires changes to the blockchain state, which involves network 
           consensus and storage allocation on the blockchain.



       Memory - 

          Memory refers to temporary data storage 
          that only exists during the execution of a function.
          it is cheaper than storage because it is not stored on the blockchain and is only 
          kept in the node's memory while the function is executing. Once the function finishes 
          execution, the data is discarded.    


          Temporary: Data in memory is erased once the function execution ends.
                     function execution ends. 

           Cheaper than storage: Writing to memory is significantly cheaper in terms of gas costs 
           compared to storage because it does not involve writing to the blockchain.

           Not persistent: Data in memory is not stored permanently and cannot be 
           accessed outside the function that created it.

           Used for function Arguments/Local Variables: 
           When passing large structures or arrays into functions, they are often stored 
           in memory for cheaper gas consumption.  

           example - 

           contract StringExample  {
              
              function addStrings(string memory a, string memory b ) public pure returns (string memory) {
                string memory result = string(abi.encodedPacked(a,b));
                return result;
              }
           }           