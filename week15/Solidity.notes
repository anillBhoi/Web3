# What is Solidity ? 
 
 Solidity is a high-level, statically-typed programming language used to write smart contracts for Etherium
 and other blockchain platforms that are compatible with the Etherium Virtual machine (EVM). These smart contracts are self-executing contracts with the terms 
 of the agreement directly written into code.



#ABIs 
  In Etherium, an ABI(application Binary interface) is a standardized way for interacting with smart contracts. it defines how data should be encoded and 
  decoded when being sent to and from a contract on the Etherium blockchain.



Solidity Version
  - The version statement at the top of a 
  Solidity contract specifies the version of the solididy 
  compiler that should be used to compile the contract.


  ex - 

  pragma solidity ^0.8.0;

  contract Sum {
    function sum(uint a, uint b) public pur
        return (a+b, a);
  }



# Variables -> 
      In Solidity, variables are used to store data within a contract. They can 
      hold different types of values and are fundamental to writing smart contracts.

      for example - for a Decentralized Uber app, 
                    You would store things like 

                    1.Rides
                    2.Users
                    3.Locations
                    4.Payments


     Types of Variables 

     1.Unsigend Numbers 
         a.uint8 = small Numbers  //here u is for unsigned means the number is not negative 
         b.uint16 = 16 bit Numbers
         c.uint255 = 256 bit number(uint)    


         ex - 

          contract Sum {
            unit8 gender;
            unit calls;
            unit bigNumber = 100000;
          }           


      2.Signed Numbers 

             a.int
             b.int32

     3.Booleans
        1.true
        2.false

     4.Addresses 

         - address store an etherium address              


     5.Strings    



# Constructor 

      A Constructor in Solidity is a special function that is executed only once during the 
      deployment of the contract. Its primarly purpose is to initialize the contracts state variables and set up any required 
      logic when the contract is deployed to the Etherium blockchain.


      ex - 

      pragma solidity ^0.8.0;

      contract Calculator {
        uint256 currentValue;

        constructor(uint256 _initialValue) {
              currentValue = _initialValue;
        }
      }

#Two types of functions:

  - State-changing functions: Functions that modify state variables, interact with other 
    contracts, or send/recieve Ether require a transaction and are considerd "non-view" functions.
   
  - view  functions : 

# View 

   In Solidity, the view keyword indicates that the function does not modify the state of the blockchain.
   It is a type of function modifier that tells the Etherium virtual machine (EVM) that the function is read-only ad will
   not alter any operations that would require a transaction.


# Mapping 

   In Solidity, a mapping is a data structure that allows you to store and look up key-value pairs.
   It's similar to a hash table or dictionary in other programming languages.


   ex- 

       1.create mapping -
          mapping(address => string) public names;

       2.Insert into a mapping -
          names[msg.sender] = _name;

       3.Get from a mapping 
           names[_address];   
             


 #Assignment ->

     Q. Create a user contract where users can come and sign up   


     -------> 

     pragma solidity ^0.8.0;

     contract NameRegistry {

      mapping(address => string) public names;

      function setName(string memory _name) public {
        names[msg.sender] = _name;
      }

      function getName(address _addres) public view returns (string memory) {
        return names[_address];
      }
     }         


          


# Arrays 

  There are two types of arrays in Solidity 

        1.Fixed-size arrays:  Arrays where the size is defined when the array is created, and it cannot be changed afterward.

        example - 
         uint[3] public numbers;

        2.Dynamic Arrays : Arrays where the size can change dynamically during execution(i.e, you can add or remove elements).

        example -
            uint[] public numbers;



# Struct 

    In solidity, a struct is a custom data type that allows you to group multiple 
    variables (of different types) together into a single unit.

    example - 

    struct Person {
      string name;
      uint age;
      address add;
    }
    Person public person;
    
     function setPerson(string memory _name, uint _age, address _add) public {
      person.name = _name;
      person.age = _age;
      person.add = _add;
     }



# Assingment 2 - create a personsContract 

--> 

   contract PersonContract {

    struct Person {
        string name;
        uint age; 
        address addr;
    }

    mapping(address => Person) public persons;

    function setPerson(string memory _name, uint _age) public {
      persons[msg.seder] = Person({
        name; _name,
        age: _age,
        addr: msg.sender
      });
    }

    function getPerson() public view returns(string memory, uint, address){
       Person memory person = persons[msg.sender];
       return (person.name, person.age, person.addr);
    }
   }




# Memory VS Stack VS Storage 


      In Solidity, Memory, Stack, and Storage are three distinct locations where data can be stored.
      Each has its own characteristics, use cases, and costs.


      Storage - 

           Stoage refers to the presistent data that is saved on the blockchain. it is used for state 
           variables that you declare at the contract level.
           Data stored in storage is written to the blockchain and remains there permanently, 
           accross function calls and transactions, untill it is explicitly modified.  

           Writing to storage is costly in terms of gas 
           because it requires changes to the blockchain state, which involves network 
           consensus and storage allocation on the blockchain.



       Memory - 

          Memory refers to temporary data storage 
          that only exists during the execution of a function.
          it is cheaper than storage because it is not stored on the blockchain and is only 
          kept in the node's memory while the function is executing. Once the function finishes 
          execution, the data is discarded.    


          Temporary: Data in memory is erased once the function execution ends.
                     function execution ends. 

           Cheaper than storage: Writing to memory is significantly cheaper in terms of gas costs 
           compared to storage because it does not involve writing to the blockchain.

           Not persistent: Data in memory is not stored permanently and cannot be 
           accessed outside the function that created it.

           Used for function Arguments/Local Variables: 
           When passing large structures or arrays into functions, they are often stored 
           in memory for cheaper gas consumption.  

           example - 

           contract StringExample  {
              
              function addStrings(string memory a, string memory b ) public pure returns (string memory) {
                string memory result = string(abi.encodedPacked(a,b));
                return result;
              }
           }           


        Stack - 

            The Stack in Solidity is a limited, low-level data structure used to store small, temporary values that are used 
            during the execution of a function. it is a akin to a "call stack" in other programming languages. 
            When you call a function, the EVM pushes temporary values (such as function arguments and local variables ) onto the stack.




   # Modifiers -> 

       In Solidity, Modifiers are a powerfull feature that allows you to modify 
       the behavior of functions in a reusable and declarative way.They are used to add 
       additional checks or functionality to a function or group of functions, before or after 
       the main logic is executed.          



       pragma solidity ^0.8.0;

       contract Example {
         address public owner;

         constructor() {
          owner = msg.sender;   // set the deployer as the owner
         }

         modifier onlyOwner() {
          require(msg.sender == owner, "You are not the owner");
         }

         // function that only the owner can call 

         function setOwner(address newOwner) public onlyOwner {
          owner = newOwner;
         }

         function sum(uint a, uint b) public view onlyOwner returns (uint) {
          return a + b;
         }

       }




  # Pure functions 


        In Solidity, Pure functions are functions that do not read from or modify the blockchain state.
        They only rely on their input paramertere to perform calculations or operations and return a result.
        Importantly, Pure functions do not intercat with any state variables or external contracts.     

        example - 

           function sumAndmul(uint a, uint b)  public pure returns (uint, uint) {
            return (a + bm a *b);
           }


          #Events 

            In Etherium, Events are a mechanism that allows smart contracts to log information on the blockchain, which can then be accessede by external consumers (e.g. front-end applications, other contracts, or off-chaian services like oracles).
            Events enable smart contracts to emit logs that can be used for debugging, indexing, or 
            triggring external actions based on contract activity.


            Example -> 
            pragma solidity ^0.8.0;

            contract EventExample {
              

                // Declare the event with txn parameters : an address and a uint 
                event Transfer(address indexed from, address indexed to, uint256 value);  // here indexed cam be used to search all txns from a specific user later

                // Aa funtion that emits the Transfer event

                function transfer(address to, uint256 value) public {

                  // Emitting the event with the specified parameters 
                   emit Transfer(msg.sender, to, value);
                }
            } 



       Example -> Get all transactions from a specific address

       (using express as backend )

      const web3 = require('web3');
      const web3 = new web3("https://localhost:8545");

      // Contract ABI and address 
      const contractAddress = "OxYourContractAddress";
      const abi = [

      ]

      // create a contract instance
      const contract = new web3.eth.Contract(abi, contractAddress);

      // Listen for the Transfer event 
      contract.events.Transfer({
        filter: {
          from: "0xsenderAddress" }, // optional filtering
          fromBlock : 0
      }, (error, event) => {
         
         if(error ){
          console.error(error);
         }else{
          console.log(`Transfer from ${event.returnValues.from} to ${event.returnValue.to} of value ${event.returnValues.value} `);
         }
      })

     



#  Part 3 

   # CCI (Cross contract invocation)

           -- CCI is a feature where two independent contracts are calls each other when the user1 calls via any one contract 

                ex - user1 -> contract2 -> contract1 (functions like add())

                here user can use or call add function which is in contract1 via contract 2 indirectly. 


                  defination ->
                     A cross-contract calls refers to a scenario where one smart contract interacts with 
                     another contract invoking its functions.

                     This is a fundamental concept in blockchain programming, 
                     enabling modular, reusable, and composable systems.



                     Before we can call a contract, we need to define the 
                     struture of the contract in an interface.


                     # Interfaces 
                        -> An interfaces in Solidity is a way to define a contract's external functions 
                        without providing their implementation.



                             ---> Properties of Interfaces 

                                     1. Functions declartions only:
                                          a. Interfaces only allow function declarations without implementation.
                                          b. functions must be external.

                                     2. No State variables        